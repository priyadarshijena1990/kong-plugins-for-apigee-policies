[{"time": 4, "file_path": "apigee-policies-based-plugins/key-value-map-operations/schema.lua", "prior_state": "local typedefs = require \"kong.db.schema.typedefs\"\n\nreturn {\n  name = \"key-value-map-operations\",\n  fields = {\n    { consumer = typedefs.no_consumer },\n    { route = typedefs.no_route },\n    { service = typedefs.no_service },\n    {\n      config = {\n        type = \"record\",\n        fields = {\n          {\n            kvm_name = {\n              type = \"string\",\n              required = true,\n              description = \"The name of the Kong shared dictionary (configured via `lua_shared_dict` in Nginx) to operate on.\",\n            },\n          },\n          {\n            operation_type = {\n              type = \"string\",\n              required = true,\n              enum = { \"get\", \"put\", \"delete\" },\n              description = \"The Key-Value Map operation to perform.\",\n            },\n          },\n          {\n            key_source_type = {\n              type = \"string\",\n              required = true,\n              enum = { \"header\", \"query\", \"body\", \"shared_context\", \"literal\" },\n              description = \"Specifies where to get the key for the KVM operation.\",\n            },\n          },\n          {\n            key_source_name = {\n              type = \"string\",\n              description = \"The name of the header/query parameter, the JSON path for a 'body' source, the key in `kong.ctx.shared`, or the literal value itself if `key_source_type` is 'literal'.\",\n            },\n          },\n          {\n            value_source_type = {\n              type = \"string\",\n              enum = { \"header\", \"query\", \"body\", \"shared_context\", \"literal\" },\n              description = \"Required for 'put' operation: Specifies where to get the value to put into the KVM.\",\n            },\n          },\n          {\n            value_source_name = {\n              type = \"string\",\n              description = \"Required for 'put' operation: The name of the header/query parameter, the JSON path for a 'body' source, the key in `kong.ctx.shared`, or the literal value itself if `value_source_type` is 'literal'.\",\n            },\n          },\n          {\n            output_destination_type = { \n              type = \"string\",\n              enum = { \"header\", \"query\", \"body\", \"shared_context\" },\n              description = \"Required for 'get' operation: Specifies where to place the retrieved value.\",\n            },\n          },\n          {\n            output_destination_name = {\n              type = \"string\",\n              description = \"Required for 'get' operation: The name of the header/query parameter, the JSON path for a 'body' destination, or the key in `kong.ctx.shared` where the retrieved value will be stored.\",\n            },\n          },\n          {\n            ttl = {\n              type = \"number\",\n              between = { 0, 31536000 }, -- 0 for no expiry, up to 1 year\n              description = \"Optional, for 'put' operation: Time-to-live for the entry in seconds. If 0, the entry does not expire. Defaults to no expiry if not set.\",\n            },\n          },\n          {\n            on_error_status = {\n              type = \"number\",\n              default = 500,\n              between = { 400, 599 },\n              description = \"The HTTP status code to return to the client if the KVM operation fails and `on_error_continue` is `false`.\",\n            },\n          },\n          {\n            on_error_body = {\n              type = \"string\",\n              default = \"Key-Value Map operation failed.\",\n              description = \"The response body to return to the client if the KVM operation fails and `on_error_continue` is `false`.\",\n            },\n          },\n          {\n            on_error_continue = {\n              type = \"boolean\",\n              default = false,\n              description = \"If `true`, request processing will continue even if the KVM operation fails. If `false`, the request will be terminated.\",\n            },\n          },\n        },\n      },\n    },\n  },\n}\n",\n    "current_state": "local typedefs = require \"kong.db.schema.typedefs\"\n\nreturn {\n  name = \"key-value-map-operations\",\n  fields = {\n    { consumer = typedefs.no_consumer },\n    { route = typedefs.no_route },\n    { service = typedefs.no_service },\n    {\n      config = {\n        type = \"record\",\n        fields = {\n          {\n            policy = {\n              type = \"string\",\n              required = true,\n              enum = { \"local\", \"cluster\" },\n              default = \"local\",\n              description = \"The policy to use for storing KVM data. 'local' uses a shared memory dictionary on each node. 'cluster' uses the Kong database to share data across all nodes.\",\n            },\n          },\n          {\n            kvm_name = {\n              type = \"string\",\n              required = true,\n              description = \"The name of the KVM. For 'local' policy, this is the name of the shared dictionary. For 'cluster' policy, this is a namespace within the shared KVM table.\",\n            },\n          },\n          {\n            operation_type = {\n              type = \"string\",\n              required = true,\n              enum = { \"get\", \"put\", \"delete\" },\n              description = \"The Key-Value Map operation to perform.\",\n            },\n          },\n          {\n            key_source_type = {\n              type = \"string\",\n              required = true,\n              enum = { \"header\", \"query\", \"body\", \"shared_context\", \"literal\" },\n              description = \"Specifies where to get the key for the KVM operation.\",\n            },\n          },\n          {\n            key_source_name = {\n              type = \"string\",\n              description = \"The name of the header/query parameter, the JSON path for a 'body' source, the key in `kong.ctx.shared`, or the literal value itself if `key_source_type` is 'literal'.\",\n            },\n          },\n          {\n            value_source_type = {\n              type = \"string\",\n              enum = { \"header\", \"query\", \"body\", \"shared_context\", \"literal\" },\n              description = \"Required for 'put' operation: Specifies where to get the value to put into the KVM.\",\n            },\n          },\n          {\n            value_source_name = {\n              type = \"string\",\n              description = \"Required for 'put' operation: The name of the header/query parameter, the JSON path for a 'body' source, the key in `kong.ctx.shared`, or the literal value itself if `value_source_type` is 'literal'.\",\n            },\n          },\n          {\n            output_destination_type = { \n              type = \"string\",\n              enum = { \"header\", \"query\", \"body\", \"shared_context\" },\n              description = \"Required for 'get' operation: Specifies where to place the retrieved value.\",\n            },\n          },\n          {\n            output_destination_name = {\n              type = \"string\",\n              description = \"Required for 'get' operation: The name of the header/query parameter, the JSON path for a 'body' destination, or the key in `kong.ctx.shared` where the retrieved value will be stored.\",\n            },\n          },\n          {\n            ttl = {\n              type = \"number\",\n              between = { 0, 31536000 }, -- 0 for no expiry, up to 1 year\n              description = \"Optional, for 'put' operation: Time-to-live for the entry in seconds. If 0, the entry does not expire. Defaults to no expiry if not set.\",\n            },\n          },\n          {\n            on_error_status = {\n              type = \"number\",\n              default = 500,\n              between = { 400, 599 },\n              description = \"The HTTP status code to return to the client if the KVM operation fails and `on_error_continue` is `false`.\",\n            },\n          },\n          {\n            on_error_body = {\n              type = \"string\",\n              default = \"Key-Value Map operation failed.\",\n              description = \"The response body to return to the client if the KVM operation fails and `on_error_continue` is `false`.\",\n            },\n          },\n          {\n            on_error_continue = {\n              type = \"boolean\",\n              default = false,\n              description = \"If `true`, request processing will continue even if the KVM operation fails. If `false`, the request will be terminated.\",\n            },\n          },\n        },\n      },\n    },\n  },\n}\n",\n  },\n  {\n    "time": 1733390000,\n    "file_path": "tests/access-entity/test_access_entity.lua",\n    "prior_state": "(new file)",\n    "current_state": "-- Unit tests for the access-entity plugin\n\nlocal handler_module = require(\"kong.plugins.access-entity.handler\")\nlocal AccessEntityHandler = handler_module -- The module itself is the handler class\n\nlocal mock_kong = {}\nlocal function reset_mock_kong()\n    mock_kong = {\n        client = {\n            get_consumer = function() return nil end,\n            get_consumer_groups = function() return {}, nil end,\n        },\n        ctx = {\n            shared = {},\n        },\n        log = {\n            err_called = false,\n            warn_called = false,\n            err_args = nil,\n            warn_args = nil,\n            debug_args = nil,\n            err = function(...) mock_kong.log.err_called = true; mock_kong.log.err_args = {...} end,\n            warn = function(...) mock_kong.log.warn_called = true; mock_kong.log.warn_args = {...} end,\n            debug = function(...) end, -- Suppress debug logs in tests for cleaner output\n        },\n        -- Mocking super access method as it's called internally\n        super = {\n          access = function() end,\n        },\n    }\nend\n\n-- --- Test: new() method (basic instance creation) ---\ndo\n    reset_mock_kong()\n    local instance = AccessEntityHandler:new()\n    assert(instance ~= nil, \"Handler instance should be created\")\n    assert(getmetatable(instance).__index == AccessEntityHandler, \"Instance should have correct metatable\")\nend\n\n-- --- Scenario 1: Successful consumer retrieval and shared context population ---\ndo\n    reset_mock_kong()\n    local conf = {\n        context_variable_name = \"test_consumer_entity\",\n    }\n    local mock_consumer = {\n        id = \"consumer-123\",\n        username = \"testuser\",\n        custom_id = \"external-id-abc\",\n        created_at = 1678886400,\n        tags = {\"app:frontend\", \"env:dev\"},\n    }\n    local mock_groups = {\n        { name = \"gold_users\" },\n        { name = \"internal_api_access\" },\n    }\n\n    mock_kong.client.get_consumer = function() return mock_consumer end\n    mock_kong.client.get_consumer_groups = function() return mock_groups, nil end\n    \n    local instance = AccessEntityHandler:new()\n    instance:access(conf)\n\n    assert(mock_kong.ctx.shared[conf.context_variable_name] ~= nil, \"Shared context should contain consumer entity\")\n    local entity = mock_kong.ctx.shared[conf.context_variable_name]\n    assert(entity.id == mock_consumer.id, \"Consumer ID should match\")\n    assert(entity.username == mock_consumer.username, \"Consumer username should match\")\n    assert(entity.custom_id == mock_consumer.custom_id, \"Consumer custom_id should match\")\n    assert(entity.created_at == mock_consumer.created_at, \"Consumer created_at should match\")\n    assert(#entity.tags == #mock_consumer.tags, \"Consumer tags count should match\")\n    assert(entity.tags[1] == mock_consumer.tags[1], \"Consumer tag 1 should match\")\n    assert(entity.tags[2] == mock_consumer.tags[2], \"Consumer tag 2 should match\")\n    assert(#entity.groups == #mock_groups, \"Consumer groups count should match\")\n    assert(entity.groups[1] == mock_groups[1].name, \"Consumer group 1 should match\")\n    assert(entity.groups[2] == mock_groups[2].name, \"Consumer group 2 should match\")\n    assert(mock_kong.log.debug_called == nil, \"No debug log for successful operation\")\n    assert(mock_kong.log.err_called == false, \"No error should be logged\")\nend\n\n-- --- Scenario 2: No authenticated consumer found ---\ndo\n    reset_mock_kong()\n    local conf = {\n        context_variable_name = \"test_consumer_entity\",\n    }\n    mock_kong.client.get_consumer = function() return nil end -- No consumer\n    \n    local instance = AccessEntityHandler:new()\n    instance:access(conf)\n\n    assert(mock_kong.ctx.shared[conf.context_variable_name] == nil, \"Shared context should not contain consumer entity\")\n    assert(mock_kong.log.err_called == false, \"No error should be logged\")\n    assert(mock_kong.log.warn_called == false, \"No warning should be logged\")\n    assert(mock_kong.log.debug_called == nil or mock_kong.log.debug_called == true, \"Debug log for no consumer found should be present\")\n    assert(string.find(mock_kong.log.err_args and mock_kong.log.err_args[1] or \"\", \"No authenticated consumer found. Skipping.\"), \"Debug log should indicate skipping\")\nend\n\n-- --- Scenario 3: Error fetching consumer groups ---\ndo\n    reset_mock_kong()\n    local conf = {\n        context_variable_name = \"test_consumer_entity\",\n    }\n    local mock_consumer = {\n        id = \"consumer-456\",\n        username = \"anotheruser\",\n    }\n    local mock_error = \"database error\"\n\n    mock_kong.client.get_consumer = function() return mock_consumer end\n    mock_kong.client.get_consumer_groups = function() return nil, mock_error end -- Simulate error\n    \n    local instance = AccessEntityHandler:new()\n    instance:access(conf)\n\n    assert(mock_kong.ctx.shared[conf.context_variable_name] ~= nil, \"Shared context should still contain consumer entity without groups\")\n    local entity = mock_kong.ctx.shared[conf.context_variable_name]\n    assert(entity.id == mock_consumer.id, \"Consumer ID should match\")\n    assert(entity.username == mock_consumer.username, \"Consumer username should match\")\n    assert(#entity.groups == 0, \"Consumer groups should be empty\")\n    assert(mock_kong.log.err_called == true, \"Error should be logged for group fetch failure\")\n    assert(string.find(mock_kong.log.err_args[1], \"Could not fetch consumer groups\"), \"Error message should indicate group fetch error\")\nend\n\n-- --- Scenario 4: Custom context variable name ---\ndo\n    reset_mock_kong()\n    local conf = {\n        context_variable_name = \"my_custom_consumer_var\",\n    }\n    local mock_consumer = {\n        id = \"consumer-789\",\n        username = \"customvaruser\",\n    }\n    mock_kong.client.get_consumer = function() return mock_consumer end\n    mock_kong.client.get_consumer_groups = function() return {}, nil end\n    \n    local instance = AccessEntityHandler:new()\n    instance:access(conf)\n\n    assert(mock_kong.ctx.shared[\"my_custom_consumer_var\"] ~= nil, \"Shared context should use custom variable name\")\n    assert(mock_kong.ctx.shared[\"my_custom_consumer_var\"].id == mock_consumer.id, \"Consumer ID should match in custom variable\")\nend\n\nprint(\"All access-entity unit tests passed successfully!\")"\n  },\n  {\n    "time": 1733390000,\n    "file_path": "tests/assert-condition/test_assert_condition.lua",\n    "prior_state": "(new file)",\n    "current_state": "-- Unit tests for the assert-condition plugin\n\nlocal handler_module = require(\"kong.plugins.assert-condition.handler\")\nlocal AssertConditionHandler = handler_module\n\nlocal mock_kong = {}\nlocal function reset_mock_kong()\n    mock_kong = {\n        request = {\n            get_header = function(...) return nil end,\n            get_query_arg = function(...) return nil end,\n            get_path = function(...) return nil end,\n        },\n        client = {\n            get_ip = function() return nil end,\n        },\n        ctx = {\n            shared = {},\n        },\n        log = {\n            err_called = false,\n            warn_called = false,\n            debug_called = false,\n            err_args = nil,\n            warn_args = nil,\n            debug_args = nil,\n            err = function(...) mock_kong.log.err_called = true; mock_kong.log.err_args = {...} end,\n            warn = function(...) mock_kong.log.warn_called = true; mock_kong.log.warn_args = {...} end,\n            debug = function(...) mock_kong.log.debug_called = true; mock_kong.log.debug_args = {...} end,\n        },\n        response = {\n            exit_called = false,\n            exit_args = {},
            exit = function(status_code, body)\n                mock_kong.response.exit_called = true\n                mock_kong.response.exit_args = { status = status_code, body = body }\n                error(\"Kong response exit called\") -- Simulate Kong exiting the request\n            end,\n        },\n        -- Mocking super access method as it's called internally\n        super = {\n          access = function() end,\n        },\n        service = {}, -- Placeholder for sandbox access\n        router = {},  -- Placeholder for sandbox access\n    }\nend\n\n-- Helper function to run a test and catch the simulated exit error\nlocal function run_test_and_catch_exit(test_func)\n    local ok, err = pcall(test_func)\n    assert(not ok and string.find(err, \"Kong response exit called\") or ok, \"Test should either pass or simulate Kong exit, or have a controlled error\")\nend\n\n-- --- Test: new() method (basic instance creation) ---\ndo\n    reset_mock_kong()\n    local instance = AssertConditionHandler:new()\n    assert(instance ~= nil, \"Handler instance should be created\")\n    assert(getmetatable(instance).__index == AssertConditionHandler, \"Instance should have correct metatable\")\nend\n\n-- --- Scenario 1: Condition evaluates to true (continue normally) ---\ndo\n    reset_mock_kong()\n    local conf = {\n        condition = \"true\",\n        on_false_action = \"abort\", -- Should not trigger abort\n        abort_status = 403,\n        abort_message = \"Blocked\",\n        on_error_continue = false,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == false, \"Should not exit when condition is true\")\n    assert(mock_kong.log.debug_called, \"Debug log for true condition should be present\")\n    assert(string.find(mock_kong.log.debug_args[1], \"Condition evaluated to true\"), \"Debug message should confirm true condition\")\n    assert(mock_kong.log.err_called == false, \"No error should be logged\")\nend\n\n-- --- Scenario 2: Condition evaluates to false and on_false_action is abort ---\ndo\n    reset_mock_kong()\n    local conf = {\n        condition = \"false\",\n        on_false_action = \"abort\",\n        abort_status = 403,\n        abort_message = \"Blocked by condition\",\n        on_error_continue = false,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == true, \"Should exit when condition is false and action is abort\")\n    assert(mock_kong.response.exit_args.status == conf.abort_status, \"Exit status should match configured abort_status\")\n    assert(mock_kong.response.exit_args.body.message == conf.abort_message, \"Exit message should match configured abort_message\")\n    assert(mock_kong.log.debug_called, \"Debug log for false condition should be present\")\n    assert(string.find(mock_kong.log.debug_args[1], \"Condition evaluated to false\"), \"Debug message should confirm false condition\")\n    assert(mock_kong.log.err_called == false, \"No error should be logged\")\nend\n\n-- --- Scenario 3: Condition evaluates to false and on_false_action is continue ---\ndo\n    reset_mock_kong()\n    local conf = {\n        condition = \"1 == 2\", -- false\n        on_false_action = \"continue\",\n        abort_status = 400,\n        abort_message = \"Ignored\",\n        on_error_continue = false,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == false, \"Should not exit when condition is false and action is continue\")\n    assert(mock_kong.log.debug_called, \"Debug log for false condition should be present\")\n    assert(string.find(mock_kong.log.debug_args[1], \"Condition evaluated to false\"), \"Debug message should confirm false condition\")\n    assert(mock_kong.log.err_called == false, \"No error should be logged\")\nend\n\n-- --- Scenario 4: Error during condition evaluation and on_error_continue is false (default) ---\ndo\n    reset_mock_kong()\n    local conf = {\n        condition = \"not_a_valid_lua_syntax + 1\", -- Invalid Lua\n        on_false_action = \"abort\",\n        abort_status = 400,\n        abort_message = \"N/A\",\n        on_error_continue = false,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == true, \"Should exit on error when on_error_continue is false\")\n    assert(mock_kong.response.exit_args.status == 500, \"Exit status should be 500 for internal error\")\n    assert(string.find(mock_kong.response.exit_args.body.message, \"Error evaluating condition\"), \"Exit message should indicate condition evaluation error\")\n    assert(mock_kong.log.err_called, \"Error should be logged for condition evaluation failure\")\n    assert(string.find(mock_kong.log.err_args[1], \"Error during condition evaluation\"), \"Error log should indicate condition evaluation failure\")\nend\n\n-- --- Scenario 5: Error during condition evaluation and on_error_continue is true ---\ndo\n    reset_mock_kong()\n    local conf = {\n        condition = \"local a = ;\", -- Invalid Lua syntax\n        on_false_action = \"abort\",\n        abort_status = 400,\n        abort_message = \"N/A\",\n        on_error_continue = true,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == false, \"Should not exit on error when on_error_continue is true\")\n    assert(mock_kong.log.err_called, \"Error should be logged for condition evaluation failure\")\n    assert(string.find(mock_kong.log.err_args[1], \"Error during condition evaluation\"), \"Error log should indicate condition evaluation failure\")\nend\n\n-- --- Scenario 6: Condition using kong.request functions ---\ndo\n    reset_mock_kong()\n    mock_kong.ctx.shared.user_role = \"admin\"\n    local conf = {\n        condition = \"kong.request.get_header('X-Auth-Token') == 'valid-token'\",\n        on_false_action = \"abort\",\n        abort_status = 401,\n        abort_message = \"Unauthorized\",\n        on_error_continue = false,\n    }\n    mock_kong.request.get_header = function(name)\n        if name == 'X-Auth-Token' then return 'valid-token' end\n    end\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == false, \"Should not exit when header condition is true\")\n    mock_kong.request.get_header = function(name)\n        if name == 'X-Auth-Token' then return 'invalid-token' end\n    end\n    \n    run_test_and_catch_exit(function() instance:access(conf) end)\n    assert(mock_kong.response.exit_called == true, \"Should exit when header condition is false\")\n    assert(mock_kong.response.exit_args.status == 401, \"Exit status should be 401\")\nend\n\n-- --- Scenario 7: Condition using kong.ctx.shared ---\ndo\n    reset_mock_kong()\n    mock_kong.ctx.shared.user_role = \"admin\"\n    local conf = {\n        condition = \"kong.ctx.shared.user_role == 'admin'\",\n        on_false_action = \"abort\",\n        abort_status = 403,\n        abort_message = \"Forbidden\",\n        on_error_continue = false,\n    }\n    \n    local instance = AssertConditionHandler:new()\n    run_test_and_catch_exit(function() instance:access(conf) end)\n\n    assert(mock_kong.response.exit_called == false, \"Should not exit when shared context condition is true\")\n    \n    mock_kong.ctx.shared.user_role = \"guest\"\n    run_test_and_catch_exit(function() instance:access(conf) end)\n    assert(mock_kong.response.exit_called == true, \"Should exit when shared context condition is false\")\n    assert(mock_kong.response.exit_args.status == 403, \"Exit status should be 403\")\nend\n\n\nprint(\"All assert-condition unit tests passed successfully!\")"\n  }
]